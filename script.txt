/** Tombola Natalizia - Backend su Google Sheets (Apps Script Web App)
 *  Append-only:
 *  - NO undo/reset
 *  - Client tabellone usa "delta": newDraws + newEvents(PRIZE)
 *
 *  JSONP:
 *  - ?callback=...
 */

const CFG = {
  SHEETS: {
    ROOMS:  "Rooms",
    PLAYERS:"Players",
    CARDS:  "Cards",
    DRAWS:  "Draws",
    MARKS:  "Marks",
    PRIZES: "Prizes",
    EVENTS: "Events",
  },
  TABELLONE: {
    playerId: "TABELLONE",
    name: "TABELLONE",
  }
};

// -------------------- Entry points --------------------
function doGet(e){  return route_(e); }
function doPost(e){ return route_(e); }

// -------------------- Router --------------------
function route_(e){
  const p = (e && e.parameter) ? e.parameter : {};
  const action = String(p.action || "").trim();

  try{
    let out;
    switch(action){
      case "init":            out = {ok:true, init: init_()}; break;

      case "createRoom":      out = createRoom_(); break;
      case "getOpenRoom":     out = getOpenRoom_(); break;
      case "purgeAllRooms":   out = purgeAllRooms_(); break;

      // cartelle
      case "join":            out = join_(p); break;
      case "registerCards":   out = registerCards_(p); break;
      case "mark":            out = mark_(p); break;

      // tabellone
      case "draw":            out = draw_(p); break;
      case "delta":           out = delta_(p); break;

      default:
        out = { ok:false, error:"Unknown action" };
    }

    return respond_(out, p.callback);
  }catch(err){
    return respond_({ ok:false, error:String(err), stack:(err && err.stack)||"" }, p.callback);
  }
}

// -------------------- Helpers: response / sheets --------------------
function respond_(obj, callback){
  const json = JSON.stringify(obj);
  if (callback && String(callback).trim()){
    return ContentService
      .createTextOutput(`${callback}(${json});`)
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  return ContentService
    .createTextOutput(json)
    .setMimeType(ContentService.MimeType.JSON);
}

function ss_(){ return SpreadsheetApp.getActiveSpreadsheet(); }

function getOrCreateSheet_(name, headers){
  const ss = ss_();
  let sh = ss.getSheetByName(name);
  if(!sh) sh = ss.insertSheet(name);

  if(headers && headers.length){
    const firstRow = sh.getRange(1,1,1,headers.length).getValues()[0];
    const empty = firstRow.every(v => v === "" || v === null);
    if(empty){
      sh.getRange(1,1,1,headers.length).setValues([headers]);
      sh.setFrozenRows(1);
    }
  }
  return sh;
}

function init_(){
  getOrCreateSheet_(CFG.SHEETS.ROOMS,   ["roomId","createdAt","status"]);
  getOrCreateSheet_(CFG.SHEETS.PLAYERS, ["roomId","playerId","name","createdAt","lastSeenAt"]);
  getOrCreateSheet_(CFG.SHEETS.CARDS,   ["roomId","playerId","cardIndex","gridJson","numbersCsv","createdAt"]);
  getOrCreateSheet_(CFG.SHEETS.DRAWS,   ["roomId","n","drawIndex","createdAt"]);
  getOrCreateSheet_(CFG.SHEETS.MARKS,   ["roomId","playerId","cardIndex","n","marked","createdAt"]);
  getOrCreateSheet_(CFG.SHEETS.PRIZES,  ["roomId","playerId","cardIndex","prize","createdAt"]);
  getOrCreateSheet_(CFG.SHEETS.EVENTS,  ["roomId","createdAt","type","playerId","name","cardIndex","prize","payloadJson"]);
  return {sheets:Object.values(CFG.SHEETS)};
}

function lock_(fn){
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);
  try { return fn(); }
  finally { lock.releaseLock(); }
}

function nowISO_(){ return new Date().toISOString(); }

// -------------------- Fast cache (ScriptCache) --------------------
const SCACHE = CacheService.getScriptCache();
const CACHE_TTL_SEC = 21600; // 6h

function ckey_(...parts){ return parts.join("|"); }

function cacheGetJson_(key){
  const s = SCACHE.get(key);
  if(!s) return null;
  try{ return JSON.parse(s); }catch(e){ return null; }
}

function cachePutJson_(key, obj, ttlSec){
  try{ SCACHE.put(key, JSON.stringify(obj), ttlSec || CACHE_TTL_SEC); }catch(e){}
}

function cacheRemove_(key){
  try{ SCACHE.remove(key); }catch(e){}
}

function keyDrawMap_(roomId){ return ckey_("DRAWMAP", roomId); }
function keyCard_(roomId, playerId, cardIndex){ return ckey_("CARD", roomId, playerId, String(cardIndex)); }
function keyMarks_(roomId, playerId, cardIndex){ return ckey_("MARKS", roomId, playerId, String(cardIndex)); }
function keyPrizes_(roomId, playerId, cardIndex){ return ckey_("PRIZES", roomId, playerId, String(cardIndex)); }

function getDrawIndexMapFast_(roomId){
  const key = keyDrawMap_(roomId);
  const obj = cacheGetJson_(key);
  if(obj && typeof obj === "object"){
    const m = new Map();
    Object.keys(obj).forEach(k=>{
      const n = Number(k), di = Number(obj[k]);
      if(Number.isFinite(n) && Number.isFinite(di)) m.set(n, di);
    });
    return m;
  }
  const draws = getDraws_(roomId); // fallback scan (una tantum quando cache manca)
  const o = {};
  draws.forEach(d=>{
    const n = Number(d.n), di = Number(d.drawIndex);
    if(Number.isFinite(n) && Number.isFinite(di)) o[String(n)] = di;
  });
  cachePutJson_(key, o);
  const m = new Map();
  Object.keys(o).forEach(k=> m.set(Number(k), Number(o[k])) );
  return m;
}

function updateDrawIndexMapCache_(roomId, n, drawIndex){
  const key = keyDrawMap_(roomId);
  const obj = cacheGetJson_(key);
  const o = (obj && typeof obj === "object") ? obj : {};
  o[String(Number(n))] = Number(drawIndex) || 0;
  cachePutJson_(key, o);
}

function setCardCache_(roomId, playerId, cardIndex, grid, numbersCsv){
  cachePutJson_(keyCard_(roomId, playerId, cardIndex), { grid, numbersCsv: String(numbersCsv || "") });
}

function getCardFast_(roomId, playerId, cardIndex){
  const cached = cacheGetJson_(keyCard_(roomId, playerId, cardIndex));
  if(cached && cached.grid){
    const numbersSet = new Set(String(cached.numbersCsv||"").split(",").filter(Boolean).map(x=>Number(x)));
    return { grid: cached.grid, numbersSet };
  }
  const card = getCard_(roomId, playerId, cardIndex); // fallback scan
  if(card){
    const numbersCsv = [...card.numbersSet].filter(n=>Number.isFinite(n)).join(",");
    setCardCache_(roomId, playerId, cardIndex, card.grid, numbersCsv);
  }
  return card;
}

function getMarkedSetFast_(roomId, playerId, cardIndex){
  const key = keyMarks_(roomId, playerId, cardIndex);
  const cached = cacheGetJson_(key);
  if(Array.isArray(cached)){
    return new Set(cached.map(Number).filter(n=>Number.isFinite(n)));
  }
  const set = getMarkedSet_(roomId, playerId, cardIndex); // fallback scan
  cachePutJson_(key, [...set]);
  return set;
}

function applyMarkToCache_(roomId, playerId, cardIndex, n, marked){
  const key = keyMarks_(roomId, playerId, cardIndex);
  const cached = cacheGetJson_(key);
  const set = new Set(Array.isArray(cached) ? cached.map(Number) : []);
  const nn = Number(n);
  if(marked) set.add(nn); else set.delete(nn);
  cachePutJson_(key, [...set]);
  return set;
}

function getPrizeSetFast_(roomId, playerId, cardIndex){
  const key = keyPrizes_(roomId, playerId, cardIndex);
  const cached = cacheGetJson_(key);
  if(Array.isArray(cached)) return new Set(cached.map(String));

  const sh = getOrCreateSheet_(CFG.SHEETS.PRIZES);
  const last = sh.getLastRow();
  const set = new Set();
  if(last >= 2){
    const rows = sh.getRange(2,1,last-1,5).getValues();
    for(const r of rows){
      if(String(r[0])===roomId && String(r[1])===playerId && Number(r[2])===Number(cardIndex)){
        set.add(String(r[3]||""));
      }
    }
  }
  cachePutJson_(key, [...set]);
  return set;
}

function addPrizeToCache_(roomId, playerId, cardIndex, prize){
  const key = keyPrizes_(roomId, playerId, cardIndex);
  const cached = cacheGetJson_(key);
  const set = new Set(Array.isArray(cached) ? cached.map(String) : []);
  set.add(String(prize));
  cachePutJson_(key, [...set]);
}


function randRoomId_(){
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  let out = "";
  for(let i=0;i<6;i++) out += chars[Math.floor(Math.random()*chars.length)];
  return out;
}

function safeJson_(s){
  try{ return JSON.parse(s); }catch(e){ return {}; }
}

function getRoomRow_(roomId){
  init_();
  const sh = getOrCreateSheet_(CFG.SHEETS.ROOMS);
  const last = sh.getLastRow();
  if(last < 2) return null;
  const vals = sh.getRange(2,1,last-1,3).getValues();
  for(let i=0;i<vals.length;i++){
    if(String(vals[i][0]||"").trim().toUpperCase() === roomId){
      return { rowIndex: i+2, row: vals[i] };
    }
  }
  return null;
}

function getRoomStatus_(roomId){
  const r = getRoomRow_(roomId);
  return r ? String(r.row[2]||"") : "";
}

function setRoomStatus_(roomId, status){
  const r = getRoomRow_(roomId);
  if(!r) return false;
  const sh = getOrCreateSheet_(CFG.SHEETS.ROOMS);
  sh.getRange(r.rowIndex, 3).setValue(String(status));
  return true;
}

// -------------------- Rooms --------------------
function createRoom_(){
  return lock_(()=>{
    init_();
    const sh = getOrCreateSheet_(CFG.SHEETS.ROOMS);
    let roomId = randRoomId_();

    const last = sh.getLastRow();
    const existing = new Set();
    if(last >= 2){
      const vals = sh.getRange(2,1,last-1,1).getValues();
      vals.forEach(r => existing.add(String(r[0]||"")));
    }
    while(existing.has(roomId)) roomId = randRoomId_();

    sh.appendRow([roomId, nowISO_(), "open"]);
    return {ok:true, roomId};
  });
}

// room open più recente
function getOpenRoom_(){
  init_();
  const sh = getOrCreateSheet_(CFG.SHEETS.ROOMS);
  const last = sh.getLastRow();
  if(last < 2) return { ok:true, roomId:null };

  const rows = sh.getRange(2,1,last-1,3).getValues();
  let best = null;
  for(const r of rows){
    const roomId = String(r[0]||"").trim().toUpperCase();
    const createdAt = String(r[1]||"");
    const status = String(r[2]||"").trim().toLowerCase();
    if(!roomId) continue;
    if(status !== "open") continue;
    if(!best || createdAt > best.createdAt) best = { roomId, createdAt };
  }
  return { ok:true, roomId: best ? best.roomId : null };
}

// elimina tutte le righe dati preservando header
function purgeAllRooms_(){
  return lock_(()=>{
    init_();
    const allSheets = Object.values(CFG.SHEETS);
    const cleared = [];

    allSheets.forEach(name=>{
      const sh = getOrCreateSheet_(name);
      const lastRow = sh.getLastRow();
      let deleted = 0;
      if(lastRow >= 2){
        sh.deleteRows(2, lastRow - 1);
        deleted = lastRow - 1;
      }
      cleared.push({sheet:name, deleted});
    });

    return {ok:true, clearedSheets: cleared};
  });
}

// -------------------- Players / Cards (per cartelle) --------------------
function join_(p){
  const roomId = String(p.roomId || "").trim().toUpperCase();
  let name = String(p.name || "").trim();
  if(!roomId) throw new Error("Missing roomId");

  return lock_(()=>{
    init_();

    const room = getRoomRow_(roomId);
    if(!room) return {ok:false, error:"Room not found", roomId};

    let playerId = String(p.playerId || "").trim().toUpperCase();
    if(!playerId) playerId = Utilities.getUuid().slice(0,8).toUpperCase();
    if(!name) name = "Giocatore-" + playerId;

    const shP = getOrCreateSheet_(CFG.SHEETS.PLAYERS);
    const last = shP.getLastRow();
    if(last >= 2){
      const rows = shP.getRange(2,1,last-1,5).getValues();
      for(let i=0;i<rows.length;i++){
        const rid = String(rows[i][0]||"").toUpperCase();
        const pid = String(rows[i][1]||"").toUpperCase();
        if(rid===roomId && pid===playerId){
          shP.getRange(i+2, 3).setValue(name);
          shP.getRange(i+2, 5).setValue(nowISO_());
          return {ok:true, roomId, playerId, name};
        }
      }
    }

    shP.appendRow([roomId, playerId, name, nowISO_(), nowISO_()]);
    return {ok:true, roomId, playerId, name};
  });
}

function registerCards_(p){
  const roomId = String(p.roomId || "").trim().toUpperCase();
  const playerId = String(p.playerId || "").trim().toUpperCase();
  const cardsJson = String(p.cardsJson || "").trim();

  if(!roomId) throw new Error("Missing roomId");
  if(!playerId) throw new Error("Missing playerId");
  if(!cardsJson) throw new Error("Missing cardsJson");

  let cards;
  try{ cards = JSON.parse(cardsJson); }catch(e){ throw new Error("cardsJson is not valid JSON"); }
  if(!Array.isArray(cards) || cards.length<1) throw new Error("cardsJson must be a non-empty array");

  return lock_(()=>{
    init_();
    const shC = getOrCreateSheet_(CFG.SHEETS.CARDS);

    // delete old cards for player in room
    const last = shC.getLastRow();
    if(last >= 2){
      const rows = shC.getRange(2,1,last-1,6).getValues();
      for(let r=rows.length; r>=1; r--){
        const row = rows[r-1];
        if(String(row[0])===roomId && String(row[1])===playerId){
          shC.deleteRow(r+1);
        }
      }
    }

    // ✅ reset cache per questo player (evita tombole false per marks vecchie)
    for(let i=0;i<12;i++){
      cacheRemove_(keyCard_(roomId, playerId, i));
      cachePutJson_(keyMarks_(roomId, playerId, i), []);
      cachePutJson_(keyPrizes_(roomId, playerId, i), []);
    }

    cards.forEach(c=>{
      const cardIndex = Number(c.cardIndex);
      const grid = c.grid;
      if(!Number.isFinite(cardIndex)) throw new Error("cardIndex invalid");

      const numbers = [];
      for(const row of grid){
        for(const v of row){
          if(v !== null && v !== "" && v !== undefined) numbers.push(Number(v));
        }
      }
      const numbersCsv = numbers.filter(n=>Number.isFinite(n)).join(",");

      shC.appendRow([roomId, playerId, cardIndex, JSON.stringify(grid), numbersCsv, nowISO_()]);

      // ✅ cache card (così mark() non scansiona Cards)
      setCardCache_(roomId, playerId, cardIndex, grid, numbersCsv);
    });

    return {ok:true, saved: cards.length};
  });
}


// -------------------- Draws (append-only) --------------------
function draw_(p){
  const roomId = String(p.roomId || "").trim().toUpperCase();
  const n = Number(p.n);

  if(!roomId) throw new Error("Missing roomId");
  if(!Number.isFinite(n) || n<1 || n>90) throw new Error("Invalid n (1..90)");

  return lock_(()=>{
    init_();

    const st = String(getRoomStatus_(roomId) || "").trim().toLowerCase();
    if(st === "closed"){
      return { ok:false, error:"Room is closed", roomId };
    }

    // ✅ uso cache draw map (max 90 entries) invece di scansionare tutto il foglio
    const drawIndexMap = getDrawIndexMapFast_(roomId);
    if(drawIndexMap.has(n)){
      return { ok:false, error:"Number already drawn", roomId, n };
    }

    let maxIdx = 0;
    for(const di of drawIndexMap.values()) if(di > maxIdx) maxIdx = di;

    const drawIndex = maxIdx + 1;
    const ts = nowISO_();

    const shD = getOrCreateSheet_(CFG.SHEETS.DRAWS);
    shD.appendRow([roomId, n, drawIndex, ts]);

    // ✅ aggiorno cache subito
    updateDrawIndexMapCache_(roomId, n, drawIndex);

    // tabellone auto-marks (serve per calcolo premi anti-cheat)
    autoTabelloneOnDraw_(roomId, n);

    if(drawIndex >= 90){
      setRoomStatus_(roomId, "closed");
    }

    return { ok:true, roomId, n, drawIndex, at: ts };
  });
}


// -------------------- Delta (tabellone) --------------------
function delta_(p){
  const roomId = String(p.roomId || "").trim().toUpperCase();
  if(!roomId) throw new Error("Missing roomId");
  init_();

  const shD = getOrCreateSheet_(CFG.SHEETS.DRAWS);
  const shE = getOrCreateSheet_(CFG.SHEETS.EVENTS);

  const sinceDrawRow  = Number(p.sinceDrawRow);
  const sinceEventRow = Number(p.sinceEventRow);

  const useRowCursor = Number.isFinite(sinceDrawRow) || Number.isFinite(sinceEventRow);

  // ✅ FAST PATH: leggo SOLO le nuove righe (append-only)
  if(useRowCursor){
    const lastDrawRow  = shD.getLastRow();
    const lastEventRow = shE.getLastRow();

    const newDraws = [];
    const startD = Math.max(2, (Number.isFinite(sinceDrawRow) ? sinceDrawRow : 1) + 1);
    if(lastDrawRow >= startD){
      const rows = shD.getRange(startD, 1, lastDrawRow - startD + 1, 4).getValues();
      for(const r of rows){
        if(String(r[0]||"").toUpperCase() !== roomId) continue;
        newDraws.push({ roomId, n:Number(r[1]), drawIndex:Number(r[2])||0, at:String(r[3]||"") });
      }
      newDraws.sort((a,b)=>a.drawIndex-b.drawIndex);
    }

    const newEvents = [];
    const startE = Math.max(2, (Number.isFinite(sinceEventRow) ? sinceEventRow : 1) + 1);
    if(lastEventRow >= startE){
      const rows = shE.getRange(startE, 1, lastEventRow - startE + 1, 8).getValues();
      for(const r of rows){
        if(String(r[0]||"").toUpperCase() !== roomId) continue;
        if(String(r[2]||"") !== "PRIZE") continue;

        newEvents.push({
          at: String(r[1]||""),
          type: "PRIZE",
          playerId: String(r[3]||""),
          name: String(r[4]||""),
          cardIndex: Number(r[5]||0),
          prize: String(r[6]||""),
          payload: safeJson_(String(r[7]||"{}"))
        });
      }
      newEvents.sort((a,b)=> (a.at < b.at ? -1 : (a.at > b.at ? 1 : 0)));
    }

    return {
      ok:true,
      roomId,
      roomStatus: String(getRoomStatus_(roomId) || ""),
      newDraws,
      newEvents,

      // ✅ cursori row-based
      lastDrawRow,
      lastEventRow,

      // compat UI
      lastDrawIndex: newDraws.length ? newDraws[newDraws.length-1].drawIndex : Number(p.sinceDrawIndex||0)||0,
      lastEventAt: newEvents.length ? newEvents[newEvents.length-1].at : ""
    };
  }

  // ---- Legacy fallback (se qualche client vecchio chiama ancora con sinceDrawIndex/sinceEventAt) ----
  const sinceDrawIndex = Math.max(0, Number(p.sinceDrawIndex || 0) || 0);
  const sinceEventAt = String(p.sinceEventAt || "").trim();

  const newDraws = [];
  const lastD = shD.getLastRow();
  if(lastD >= 2){
    const rows = shD.getRange(2,1,lastD-1,4).getValues();
    for(const r of rows){
      if(String(r[0]||"").toUpperCase() !== roomId) continue;
      const di = Number(r[2]) || 0;
      if(di > sinceDrawIndex){
        newDraws.push({ roomId, n:Number(r[1]), drawIndex: di, at: String(r[3]||"") });
      }
    }
  }
  newDraws.sort((a,b)=>a.drawIndex-b.drawIndex);

  const newEvents = [];
  const lastE = shE.getLastRow();
  if(lastE >= 2){
    const rows = shE.getRange(2,1,lastE-1,8).getValues();
    for(const r of rows){
      if(String(r[0]||"").toUpperCase() !== roomId) continue;
      if(String(r[2]||"") !== "PRIZE") continue;

      const at = String(r[1]||"");
      if(sinceEventAt && at <= sinceEventAt) continue;

      newEvents.push({
        at,
        type: "PRIZE",
        playerId: String(r[3]||""),
        name: String(r[4]||""),
        cardIndex: Number(r[5]||0),
        prize: String(r[6]||""),
        payload: safeJson_(String(r[7]||"{}"))
      });
    }
  }
  newEvents.sort((a,b)=> (a.at < b.at ? -1 : (a.at > b.at ? 1 : 0)));

  return {
    ok:true,
    roomId,
    roomStatus: String(getRoomStatus_(roomId) || ""),
    newDraws,
    newEvents,

    // anche qui: ritorno row cursors (così puoi migrare client senza problemi)
    lastDrawRow: shD.getLastRow(),
    lastEventRow: shE.getLastRow(),

    lastDrawIndex: newDraws.length ? newDraws[newDraws.length-1].drawIndex : sinceDrawIndex,
    lastEventAt: newEvents.length ? newEvents[newEvents.length-1].at : sinceEventAt
  };
}


// -------------------- Marks + prizes (cartelle) --------------------
function mark_(p){
  const roomId = String(p.roomId || "").trim().toUpperCase();
  const playerId = String(p.playerId || "").trim().toUpperCase();
  const cardIndex = Number(p.cardIndex);
  const n = Number(p.n);
  const marked = String(p.marked||"1") === "1";

  if(!roomId) throw new Error("Missing roomId");
  if(!playerId) throw new Error("Missing playerId");
  if(!Number.isFinite(cardIndex)) throw new Error("Invalid cardIndex");
  if(!Number.isFinite(n) || n<1 || n>90) throw new Error("Invalid n (1..90)");

  return lock_(()=>{
    init_();

    const drawIndexMap = getDrawIndexMapFast_(roomId);
    if(!drawIndexMap.has(n)){
      return {ok:false, error:"Number not drawn yet", roomId, n};
    }

    const card = getCardFast_(roomId, playerId, cardIndex);
    if(!card){
      return {ok:false, error:"Card not registered", roomId, playerId, cardIndex};
    }
    if(!card.numbersSet.has(n)){
      return {ok:false, error:"Number not in card", roomId, n, cardIndex};
    }

    const shM = getOrCreateSheet_(CFG.SHEETS.MARKS);
    shM.appendRow([roomId, playerId, cardIndex, n, marked ? 1 : 0, nowISO_()]);

    // ✅ aggiorno cache marks (così non rileggo MARKS ogni click)
    const markedSet = applyMarkToCache_(roomId, playerId, cardIndex, n, marked);

    const player = getOrCreatePlayer_(roomId, playerId, null);
    const prizeSet = getPrizeSetFast_(roomId, playerId, cardIndex);

    const { newly } = computeAndRecordPrizes_(roomId, playerId, player.name, cardIndex, card.grid, n, markedSet, drawIndexMap, prizeSet);

    return {ok:true, roomId, playerId, name: player.name, cardIndex, n, marked, newly};
  });
}


// -------------------- TABELLONE logic (auto-marks per premi) --------------------
function autoTabelloneOnDraw_(roomId, n){
  const playerId = CFG.TABELLONE.playerId;
  const name = CFG.TABELLONE.name;

  getOrCreatePlayer_(roomId, playerId, name);
  ensureTabelloneCards_(roomId);

  const cardIndex = tabelloneCardIndexForNumber_(n);
  const card = getCardFast_(roomId, playerId, cardIndex);
  if(!card) return;
  if(!card.numbersSet.has(n)) return;

  const already = getMarkedSetFast_(roomId, playerId, cardIndex);
  if(already.has(n)) return;

  const shM = getOrCreateSheet_(CFG.SHEETS.MARKS);
  shM.appendRow([roomId, playerId, cardIndex, n, 1, nowISO_()]);

  const markedSet = applyMarkToCache_(roomId, playerId, cardIndex, n, true);

  const drawIndexMap = getDrawIndexMapFast_(roomId); // già aggiornato in draw_()
  const prizeSet = getPrizeSetFast_(roomId, playerId, cardIndex);

  computeAndRecordPrizes_(roomId, playerId, name, cardIndex, card.grid, n, markedSet, drawIndexMap, prizeSet);
}


function getOrCreatePlayer_(roomId, playerId, nameOrNull){
  const shP = getOrCreateSheet_(CFG.SHEETS.PLAYERS);
  const last = shP.getLastRow();
  let name = String(nameOrNull || "").trim();

  if(last >= 2){
    const rows = shP.getRange(2,1,last-1,5).getValues();
    for(let i=0;i<rows.length;i++){
      const rid = String(rows[i][0]||"").toUpperCase();
      const pid = String(rows[i][1]||"").toUpperCase();
      if(rid===roomId && pid===playerId){
        if(!name) name = String(rows[i][2] || ("Giocatore-"+playerId));
        shP.getRange(i+2, 3).setValue(name);
        shP.getRange(i+2, 5).setValue(nowISO_());
        return {roomId, playerId, name};
      }
    }
  }

  if(!name) name = "Giocatore-" + playerId;
  shP.appendRow([roomId, playerId, name, nowISO_(), nowISO_()]);
  return {roomId, playerId, name};
}

function ensureTabelloneCards_(roomId){
  const shC = getOrCreateSheet_(CFG.SHEETS.CARDS);
  const playerId = CFG.TABELLONE.playerId;

  const last = shC.getLastRow();
  if(last >= 2){
    const rows = shC.getRange(2,1,last-1,2).getValues();
    const hasAny = rows.some(r => String(r[0])===roomId && String(r[1])===playerId);
    if(hasAny) return;
  }

  const cards = buildTabelloneCards_();
  cards.forEach((grid, idx)=>{
    const nums = [];
    for(const row of grid){
      for(const v of row){
        if(v !== null && v !== "" && v !== undefined) nums.push(Number(v));
      }
    }
    const numbersCsv = nums.filter(n=>Number.isFinite(n)).join(",");
    shC.appendRow([roomId, playerId, idx, JSON.stringify(grid), numbersCsv, nowISO_()]);
  });
}

function buildTabelloneCards_(){
  const out = [];
  out.push(makeTabGrid_([1,2,3,4,5],   [11,12,13,14,15], [21,22,23,24,25]));
  out.push(makeTabGrid_([6,7,8,9,10],  [16,17,18,19,20], [26,27,28,29,30]));
  out.push(makeTabGrid_([31,32,33,34,35],[41,42,43,44,45],[51,52,53,54,55]));
  out.push(makeTabGrid_([36,37,38,39,40],[46,47,48,49,50],[56,57,58,59,60]));
  out.push(makeTabGrid_([61,62,63,64,65],[71,72,73,74,75],[81,82,83,84,85]));
  out.push(makeTabGrid_([66,67,68,69,70],[76,77,78,79,80],[86,87,88,89,90]));
  return out;
}

function makeTabGrid_(r1, r2, r3){
  function row(nums){
    const a = Array(9).fill(null);
    for(let i=0;i<nums.length;i++) a[i] = nums[i];
    return a;
  }
  return [row(r1), row(r2), row(r3)];
}

function tabelloneCardIndexForNumber_(n){
  const tens = Math.floor((n-1)/10);
  const within = ((n-1)%10) + 1;
  const group = Math.floor(tens/3);
  const base = group * 2;
  return base + (within <= 5 ? 0 : 1);
}

// -------------------- Card + marks + prizes --------------------
function getDraws_(roomId){
  const shD = getOrCreateSheet_(CFG.SHEETS.DRAWS);
  const last = shD.getLastRow();
  if(last < 2) return [];
  const rows = shD.getRange(2,1,last-1,4).getValues();

  const out = [];
  for(const r of rows){
    if(String(r[0]||"").toUpperCase() !== roomId) continue;
    out.push({ n:Number(r[1]), drawIndex:Number(r[2]), at:String(r[3]||"") });
  }
  out.sort((a,b)=>a.drawIndex-b.drawIndex);
  return out;
}

function getDrawnSet_(roomId){
  const draws = getDraws_(roomId);
  return new Set(draws.map(d=>d.n));
}

function getDrawIndexMap_(roomId){
  const draws = getDraws_(roomId);
  const map = new Map();
  draws.forEach(d => map.set(Number(d.n), Number(d.drawIndex)));
  return map;
}

function getCard_(roomId, playerId, cardIndex){
  const shC = getOrCreateSheet_(CFG.SHEETS.CARDS);
  const last = shC.getLastRow();
  if(last < 2) return null;

  const rows = shC.getRange(2,1,last-1,6).getValues();
  for(const r of rows){
    if(String(r[0])!==roomId) continue;
    if(String(r[1])!==playerId) continue;
    if(Number(r[2])!==Number(cardIndex)) continue;

    const grid = safeJson_(String(r[3]||"[]"));
    const numbersCsv = String(r[4]||"");
    const numbersSet = new Set(numbersCsv.split(",").filter(Boolean).map(x=>Number(x)));
    return { grid, numbersSet };
  }
  return null;
}

function getMarkedSet_(roomId, playerId, cardIndex){
  const shM = getOrCreateSheet_(CFG.SHEETS.MARKS);
  const last = shM.getLastRow();
  if(last < 2) return new Set();

  const rows = shM.getRange(2,1,last-1,6).getValues();
  const lastToggle = new Map();
  for(const r of rows){
    if(String(r[0])!==roomId) continue;
    if(String(r[1])!==playerId) continue;
    if(Number(r[2])!==Number(cardIndex)) continue;
    const nn = Number(r[3]);
    const mk = Number(r[4])===1;
    lastToggle.set(nn, mk);
  }
  return new Set([...lastToggle.entries()].filter(([,mk])=>mk).map(([nn])=>nn));
}

function existsPrize_(roomId, playerId, cardIndex, prize){
  const sh = getOrCreateSheet_(CFG.SHEETS.PRIZES);
  const last = sh.getLastRow();
  if(last < 2) return false;

  const rows = sh.getRange(2,1,last-1,5).getValues();
  for(const r of rows){
    if(String(r[0])===roomId && String(r[1])===playerId && Number(r[2])===Number(cardIndex) && String(r[3])===prize){
      return true;
    }
  }
  return false;
}

function computeAndRecordPrizes_(roomId, playerId, name, cardIndex, grid, triggerN, markedSetOpt, drawIndexMapOpt, prizeSetOpt){
  const markedSet = markedSetOpt || getMarkedSetFast_(roomId, playerId, cardIndex);
  const drawIndexMap = drawIndexMapOpt || getDrawIndexMapFast_(roomId);
  const prizeSet = prizeSetOpt || getPrizeSetFast_(roomId, playerId, cardIndex);

  const rowPrizes = [
    {k:2, prize:"AMBO"},
    {k:3, prize:"TERNO"},
    {k:4, prize:"QUATERNA"},
    {k:5, prize:"CINQUINA"},
  ];

  const newly = [];

  for(let r=0;r<3;r++){
    const rowNums = (grid[r]||[]).filter(v=>v!==null && v!=="" && v!==undefined).map(Number);
    const hitNums = rowNums.filter(nn=>markedSet.has(nn));

    for(const {k, prize} of rowPrizes){
      if(hitNums.length >= k && !prizeSet.has(prize)){
        const di = hitNums.reduce((mx, nn)=> Math.max(mx, Number(drawIndexMap.get(nn)||0)), 0);
        const candidates = hitNums.filter(nn => Number(drawIndexMap.get(nn)||0) === di);
        const trig = candidates.includes(Number(triggerN)) ? Number(triggerN) : (candidates[0] || Number(triggerN) || null);

        const payload = {
          row: r+1,
          hit: hitNums.length,
          marked: [...markedSet],
          winNumbers: hitNums.slice().sort((a,b)=>a-b),
          drawIndex: di,
          triggerN: trig
        };

        recordPrize_(roomId, playerId, name, cardIndex, prize, payload);
        prizeSet.add(prize);

        newly.push({prize, winNumbers: payload.winNumbers, drawIndex: di, triggerN: trig});
      }
    }
  }

  if(markedSet.size >= 15){
    const prize = "TOMBOLA";
    if(!prizeSet.has(prize)){
      const wn = [...markedSet].sort((a,b)=>a-b);
      const di = wn.reduce((mx, nn)=> Math.max(mx, Number(drawIndexMap.get(nn)||0)), 0);
      const candidates = wn.filter(nn => Number(drawIndexMap.get(nn)||0) === di);
      const trig = candidates.includes(Number(triggerN)) ? Number(triggerN) : (candidates[0] || Number(triggerN) || null);

      const payload = { hit: markedSet.size, marked: [...markedSet], winNumbers: wn, drawIndex: di, triggerN: trig };

      recordPrize_(roomId, playerId, name, cardIndex, prize, payload);
      prizeSet.add(prize);

      newly.push({prize, winNumbers: wn, drawIndex: di, triggerN: trig});
    }
  }

  return { newly };
}

function recordPrize_(roomId, playerId, name, cardIndex, prize, payload){
  const shPr = getOrCreateSheet_(CFG.SHEETS.PRIZES);
  const shEv = getOrCreateSheet_(CFG.SHEETS.EVENTS);
  const ts = nowISO_();

  const p = payload || {};
  if(!Array.isArray(p.winNumbers)) p.winNumbers = [];
  if(!Array.isArray(p.marked)) p.marked = [];
  if(!Number.isFinite(Number(p.drawIndex))) p.drawIndex = 0;
  if(!Number.isFinite(Number(p.triggerN))) p.triggerN = null;

  shPr.appendRow([roomId, playerId, cardIndex, prize, ts]);
  shEv.appendRow([roomId, ts, "PRIZE", playerId, name, cardIndex, prize, JSON.stringify(p)]);

  // ✅ aggiorna cache premi
  addPrizeToCache_(roomId, playerId, cardIndex, prize);
}
