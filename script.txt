/** XTombola Natalizia - Backend Apps Script (Web App)
 *  Obiettivo performance:
 *  - mark() O(1) (no scansioni su Marks/Prizes)
 *  - delta() veloce (usa State + tail eventi)
 *  Log audit rimane append-only: Draws, Marks, Prizes, Events
 */

const CFG = {
  SHEETS: {
    ROOMS:       "Rooms",
    PLAYERS:     "Players",
    CARDS:       "Cards",
    DRAWS:       "Draws",
    MARKS:       "Marks",
    PRIZES:      "Prizes",
    EVENTS:      "Events",

    // NUOVI
    STATE:       "State",
    MARKS_STATE: "MarksState",
    PRIZES_STATE:"PrizesState",
  },
  LIMITS: {
    EVENTS_TAIL_MAX: 120,   // quanti eventi teniamo nello snapshot (tail)
    CACHE_TTL_SEC:   30
  }
};

// -------------------- Entry points --------------------
function doGet(e){  return route_(e); }
function doPost(e){ return route_(e); }

// -------------------- Router --------------------
function route_(e){
  const p = (e && e.parameter) ? e.parameter : {};
  const action = String(p.action || "").trim();

  try{
    let out;
    switch(action){
      case "init":            out = {ok:true, init: init_()}; break;

      case "createRoom":      out = createRoom_(); break;
      case "getOpenRoom":     out = getOpenRoom_(); break;
      case "purgeAllRooms":   out = purgeAllRooms_(); break;

      // cartelle
      case "join":            out = join_(p); break;
      case "registerCards":   out = registerCards_(p); break;
      case "mark":            out = mark_(p); break;

      // tabellone
      case "draw":            out = draw_(p); break;
      case "delta":           out = delta_(p); break;

      default:
        out = { ok:false, error:"Unknown action" };
    }

    return respond_(out, p.callback);
  }catch(err){
    return respond_({ ok:false, error:String(err), stack:(err && err.stack)||"" }, p.callback);
  }
}

// -------------------- Helpers: response / sheets --------------------
function respond_(obj, callback){
  const json = JSON.stringify(obj);
  if (callback && String(callback).trim()){
    return ContentService
      .createTextOutput(`${callback}(${json});`)
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  return ContentService
    .createTextOutput(json)
    .setMimeType(ContentService.MimeType.JSON);
}

function ss_(){ return SpreadsheetApp.getActiveSpreadsheet(); }

function getOrCreateSheet_(name, headers){
  const ss = ss_();
  let sh = ss.getSheetByName(name);
  if(!sh) sh = ss.insertSheet(name);

  if(headers && headers.length){
    const firstRow = sh.getRange(1,1,1,headers.length).getValues()[0];
    const empty = firstRow.every(v => v === "" || v === null);
    if(empty){
      sh.getRange(1,1,1,headers.length).setValues([headers]);
      sh.setFrozenRows(1);
    }
  }
  return sh;
}

function init_(){
  getOrCreateSheet_(CFG.SHEETS.ROOMS,   ["roomId","createdAt","status"]);
  getOrCreateSheet_(CFG.SHEETS.PLAYERS, ["roomId","playerId","name","createdAt","lastSeenAt"]);
  getOrCreateSheet_(CFG.SHEETS.CARDS,   ["roomId","playerId","cardIndex","gridJson","numbersCsv","createdAt"]);
  getOrCreateSheet_(CFG.SHEETS.DRAWS,   ["roomId","n","drawIndex","createdAt"]);
  getOrCreateSheet_(CFG.SHEETS.MARKS,   ["roomId","playerId","cardIndex","n","marked","createdAt"]);
  getOrCreateSheet_(CFG.SHEETS.PRIZES,  ["roomId","playerId","cardIndex","prize","createdAt"]);
  getOrCreateSheet_(CFG.SHEETS.EVENTS,  ["roomId","createdAt","type","playerId","name","cardIndex","prize","payloadJson"]);

  // NUOVI
  getOrCreateSheet_(CFG.SHEETS.STATE, [
    "roomId","updatedAt","roomStatus",
    "drawsJson","lastDrawIndex",
    "eventsTailJson","eventsTailFromAt","lastEventAt"
  ]);

  getOrCreateSheet_(CFG.SHEETS.MARKS_STATE, [
    "key","roomId","playerId","cardIndex","markedCsv","updatedAt"
  ]);

  getOrCreateSheet_(CFG.SHEETS.PRIZES_STATE, [
    "key","roomId","playerId","cardIndex","prizesJson","updatedAt"
  ]);

  return {sheets:Object.values(CFG.SHEETS)};
}

// -------------------- Lock / time / cache --------------------
function lock_(fn){
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);
  try { return fn(); }
  finally { lock.releaseLock(); }
}
function nowISO_(){ return new Date().toISOString(); }
function cache_(){ return CacheService.getScriptCache(); }
function cacheGetJson_(key){
  const s = cache_().get(key);
  if(!s) return null;
  try { return JSON.parse(s); } catch(e){ return null; }
}
function cachePutJson_(key, obj){
  try { cache_().put(key, JSON.stringify(obj), CFG.LIMITS.CACHE_TTL_SEC); } catch(e){}
}
function ckState_(roomId){ return `STATE:${roomId}`; }
function ckCard_(roomId, playerId, cardIndex){ return `CARD:${roomId}:${playerId}:${cardIndex}`; }
function ckMarks_(roomId, playerId, cardIndex){ return `MARKS:${roomId}:${playerId}:${cardIndex}`; }
function ckPrizes_(roomId, playerId, cardIndex){ return `PRIZES:${roomId}:${playerId}:${cardIndex}`; }

// -------------------- Util: find row by key (TextFinder) --------------------
function findRowByExact_(sh, col, value){
  const tf = sh.createTextFinder(String(value))
    .matchEntireCell(true)
    .matchCase(true)
    .findNext();
  if(!tf) return 0;
  const r = tf.getRow();
  return r >= 2 ? r : 0;
}

function safeJson_(s){
  try{ return JSON.parse(s); }catch(e){ return {}; }
}

function randRoomId_(){
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  let out = "";
  for(let i=0;i<6;i++) out += chars[Math.floor(Math.random()*chars.length)];
  return out;
}

function roomKey_(roomId){ return String(roomId||"").trim().toUpperCase(); }
function key3_(roomId, playerId, cardIndex){
  return `${roomKey_(roomId)}|${String(playerId||"").trim().toUpperCase()}|${Number(cardIndex)}`;
}

// -------------------- Rooms helpers --------------------
function getRoomRow_(roomId){
  init_();
  const sh = getOrCreateSheet_(CFG.SHEETS.ROOMS);
  const rid = roomKey_(roomId);
  const rowIndex = findRowByExact_(sh, 1, rid);
  if(!rowIndex) return null;
  const row = sh.getRange(rowIndex,1,1,3).getValues()[0];
  return { rowIndex, row };
}
function getRoomStatus_(roomId){
  const r = getRoomRow_(roomId);
  return r ? String(r.row[2]||"") : "";
}
function setRoomStatus_(roomId, status){
  const r = getRoomRow_(roomId);
  if(!r) return false;
  const sh = getOrCreateSheet_(CFG.SHEETS.ROOMS);
  sh.getRange(r.rowIndex, 3).setValue(String(status));
  return true;
}

// -------------------- State (snapshot room) --------------------
function defaultState_(roomId){
  return {
    roomId: roomKey_(roomId),
    updatedAt: nowISO_(),
    roomStatus: String(getRoomStatus_(roomId)||""),
    draws: [],              // [{n,drawIndex,at}]
    lastDrawIndex: 0,
    eventsTail: [],         // tail PRIZE events
    eventsTailFromAt: "",
    lastEventAt: ""
  };
}

function readStateFromSheet_(roomId){
  const sh = getOrCreateSheet_(CFG.SHEETS.STATE);
  const rid = roomKey_(roomId);
  const rowIndex = findRowByExact_(sh, 1, rid);
  if(!rowIndex) return null;

  const r = sh.getRange(rowIndex,1,1,8).getValues()[0];
  const draws = safeJson_(String(r[3]||"[]"));
  const eventsTail = safeJson_(String(r[5]||"[]"));

  return {
    roomId: rid,
    updatedAt: String(r[1]||""),
    roomStatus: String(r[2]||""),
    draws: Array.isArray(draws) ? draws : [],
    lastDrawIndex: Number(r[4]||0) || 0,
    eventsTail: Array.isArray(eventsTail) ? eventsTail : [],
    eventsTailFromAt: String(r[6]||""),
    lastEventAt: String(r[7]||"")
  };
}

function saveStateToSheet_(st){
  const sh = getOrCreateSheet_(CFG.SHEETS.STATE);
  const rid = roomKey_(st.roomId);
  const rowIndex = findRowByExact_(sh, 1, rid);

  const updatedAt = nowISO_();
  const out = [
    rid,
    updatedAt,
    String(st.roomStatus||""),
    JSON.stringify(st.draws || []),
    Number(st.lastDrawIndex||0) || 0,
    JSON.stringify(st.eventsTail || []),
    String(st.eventsTailFromAt||""),
    String(st.lastEventAt||"")
  ];

  if(rowIndex){
    sh.getRange(rowIndex,1,1,out.length).setValues([out]);
  }else{
    sh.appendRow(out);
  }

  st.updatedAt = updatedAt;
  cachePutJson_(ckState_(rid), st);
  return st;
}

function rebuildStateFromLogs_(roomId){
  init_();
  const rid = roomKey_(roomId);
  const st = defaultState_(rid);

  // draws (max 90 per room, ma il foglio può contenere più room)
  const shD = getOrCreateSheet_(CFG.SHEETS.DRAWS);
  const lastD = shD.getLastRow();
  if(lastD >= 2){
    const rows = shD.getRange(2,1,lastD-1,4).getValues();
    for(const r of rows){
      if(String(r[0]||"").toUpperCase() !== rid) continue;
      st.draws.push({ roomId: rid, n:Number(r[1]), drawIndex:Number(r[2])||0, at:String(r[3]||"") });
    }
    st.draws.sort((a,b)=>a.drawIndex-b.drawIndex);
    st.lastDrawIndex = st.draws.length ? st.draws[st.draws.length-1].drawIndex : 0;
  }

  // events (solo PRIZE) - qui leggiamo tutto solo in rebuild (raro)
  const shE = getOrCreateSheet_(CFG.SHEETS.EVENTS);
  const lastE = shE.getLastRow();
  const allEvents = [];
  if(lastE >= 2){
    const rows = shE.getRange(2,1,lastE-1,8).getValues();
    for(const r of rows){
      if(String(r[0]||"").toUpperCase() !== rid) continue;
      if(String(r[2]||"") !== "PRIZE") continue;
      const at = String(r[1]||"");
      allEvents.push({
        at,
        type: "PRIZE",
        playerId: String(r[3]||""),
        name: String(r[4]||""),
        cardIndex: Number(r[5]||0),
        prize: String(r[6]||""),
        payload: safeJson_(String(r[7]||"{}"))
      });
    }
    allEvents.sort((a,b)=> (a.at < b.at ? -1 : (a.at > b.at ? 1 : 0)));
  }

  st.lastEventAt = allEvents.length ? allEvents[allEvents.length-1].at : "";
  st.eventsTail = allEvents.slice(-CFG.LIMITS.EVENTS_TAIL_MAX);
  st.eventsTailFromAt = st.eventsTail.length ? String(st.eventsTail[0].at||"") : "";

  // status
  st.roomStatus = String(getRoomStatus_(rid) || "");
  return saveStateToSheet_(st);
}

function getState_(roomId){
  const rid = roomKey_(roomId);
  const cached = cacheGetJson_(ckState_(rid));
  if(cached && cached.roomId === rid) return cached;

  const fromSheet = readStateFromSheet_(rid);
  if(fromSheet){
    cachePutJson_(ckState_(rid), fromSheet);
    return fromSheet;
  }

  // se manca completamente (prima esecuzione o sheet nuovo), rebuild
  return rebuildStateFromLogs_(rid);
}

function pushEventToStateTail_(st, ev){
  const tail = Array.isArray(st.eventsTail) ? st.eventsTail : [];
  tail.push(ev);
  while(tail.length > CFG.LIMITS.EVENTS_TAIL_MAX) tail.shift();
  st.eventsTail = tail;
  st.eventsTailFromAt = tail.length ? String(tail[0].at||"") : "";
  st.lastEventAt = tail.length ? String(tail[tail.length-1].at||"") : st.lastEventAt;
  return st;
}

// -------------------- Rooms --------------------
function createRoom_(){
  return lock_(()=>{
    init_();
    const sh = getOrCreateSheet_(CFG.SHEETS.ROOMS);
    let roomId = randRoomId_();

    const last = sh.getLastRow();
    const existing = new Set();
    if(last >= 2){
      const vals = sh.getRange(2,1,last-1,1).getValues();
      vals.forEach(r => existing.add(String(r[0]||"").trim().toUpperCase()));
    }
    while(existing.has(roomId)) roomId = randRoomId_();

    sh.appendRow([roomId, nowISO_(), "open"]);

    // crea anche State subito
    const st = defaultState_(roomId);
    st.roomStatus = "open";
    saveStateToSheet_(st);

    return {ok:true, roomId};
  });
}

// room open più recente
function getOpenRoom_(){
  init_();
  const sh = getOrCreateSheet_(CFG.SHEETS.ROOMS);
  const last = sh.getLastRow();
  if(last < 2) return { ok:true, roomId:null };

  const rows = sh.getRange(2,1,last-1,3).getValues();
  let best = null;
  for(const r of rows){
    const roomId = String(r[0]||"").trim().toUpperCase();
    const createdAt = String(r[1]||"");
    const status = String(r[2]||"").trim().toLowerCase();
    if(!roomId) continue;
    if(status !== "open") continue;
    if(!best || createdAt > best.createdAt) best = { roomId, createdAt };
  }
  return { ok:true, roomId: best ? best.roomId : null };
}

// elimina tutte le righe dati preservando header
function purgeAllRooms_(){
  return lock_(()=>{
    init_();
    const allSheets = Object.values(CFG.SHEETS);
    const cleared = [];

    allSheets.forEach(name=>{
      const sh = getOrCreateSheet_(name);
      const lastRow = sh.getLastRow();
      let deleted = 0;
      if(lastRow >= 2){
        sh.deleteRows(2, lastRow - 1);
        deleted = lastRow - 1;
      }
      cleared.push({sheet:name, deleted});
    });

    return {ok:true, clearedSheets: cleared};
  });
}

// -------------------- Players / Cards --------------------
function join_(p){
  const roomId = roomKey_(p.roomId);
  let name = String(p.name || "").trim();
  if(!roomId) throw new Error("Missing roomId");

  return lock_(()=>{
    init_();

    const room = getRoomRow_(roomId);
    if(!room) return {ok:false, error:"Room not found", roomId};

    let playerId = String(p.playerId || "").trim().toUpperCase();
    if(!playerId) playerId = Utilities.getUuid().slice(0,8).toUpperCase();
    if(!name) name = "Giocatore-" + playerId;

    const shP = getOrCreateSheet_(CFG.SHEETS.PLAYERS);
    const last = shP.getLastRow();
    if(last >= 2){
      const rows = shP.getRange(2,1,last-1,5).getValues();
      for(let i=0;i<rows.length;i++){
        const rid = String(rows[i][0]||"").toUpperCase();
        const pid = String(rows[i][1]||"").toUpperCase();
        if(rid===roomId && pid===playerId){
          shP.getRange(i+2, 3).setValue(name);
          shP.getRange(i+2, 5).setValue(nowISO_());
          return {ok:true, roomId, playerId, name};
        }
      }
    }

    shP.appendRow([roomId, playerId, name, nowISO_(), nowISO_()]);
    return {ok:true, roomId, playerId, name};
  });
}

function registerCards_(p){
  const roomId = roomKey_(p.roomId);
  const playerId = String(p.playerId || "").trim().toUpperCase();
  const cardsJson = String(p.cardsJson || "").trim();

  if(!roomId) throw new Error("Missing roomId");
  if(!playerId) throw new Error("Missing playerId");
  if(!cardsJson) throw new Error("Missing cardsJson");

  let cards;
  try{ cards = JSON.parse(cardsJson); }catch(e){ throw new Error("cardsJson is not valid JSON"); }
  if(!Array.isArray(cards) || cards.length<1) throw new Error("cardsJson must be a non-empty array");

  return lock_(()=>{
    init_();
    const shC = getOrCreateSheet_(CFG.SHEETS.CARDS);

    // delete old cards for player in room
    const last = shC.getLastRow();
    if(last >= 2){
      const rows = shC.getRange(2,1,last-1,6).getValues();
      for(let r=rows.length; r>=1; r--){
        const row = rows[r-1];
        if(String(row[0])===roomId && String(row[1])===playerId){
          shC.deleteRow(r+1);
        }
      }
    }

    cards.forEach(c=>{
      const cardIndex = Number(c.cardIndex);
      const grid = c.grid;
      if(!Number.isFinite(cardIndex)) throw new Error("cardIndex invalid");

      const numbers = [];
      for(const row of grid){
        for(const v of row){
          if(v !== null && v !== "" && v !== undefined) numbers.push(Number(v));
        }
      }
      const numbersCsv = numbers.filter(n=>Number.isFinite(n)).join(",");
      shC.appendRow([roomId, playerId, cardIndex, JSON.stringify(grid), numbersCsv, nowISO_()]);

      // reset cache card
      cache_().remove(ckCard_(roomId, playerId, cardIndex));
    });

    return {ok:true, saved: cards.length};
  });
}

function getCard_(roomId, playerId, cardIndex){
  const rid = roomKey_(roomId);
  const pid = String(playerId||"").trim().toUpperCase();
  const cix = Number(cardIndex);

  const ck = ckCard_(rid, pid, cix);
  const cached = cacheGetJson_(ck);
  if(cached && cached.grid && cached.numbersCsv != null){
    const numbersSet = new Set(String(cached.numbersCsv).split(",").filter(Boolean).map(x=>Number(x)));
    return { grid: cached.grid, numbersSet };
  }

  const shC = getOrCreateSheet_(CFG.SHEETS.CARDS);
  const last = shC.getLastRow();
  if(last < 2) return null;

  const rows = shC.getRange(2,1,last-1,6).getValues();
  for(const r of rows){
    if(String(r[0])!==rid) continue;
    if(String(r[1])!==pid) continue;
    if(Number(r[2])!==cix) continue;

    const grid = safeJson_(String(r[3]||"[]"));
    const numbersCsv = String(r[4]||"");
    const numbersSet = new Set(numbersCsv.split(",").filter(Boolean).map(x=>Number(x)));

    cachePutJson_(ck, { grid, numbersCsv });
    return { grid, numbersSet };
  }
  return null;
}

// -------------------- Draws (append-only) --------------------
function draw_(p){
  const roomId = roomKey_(p.roomId);
  const n = Number(p.n);

  if(!roomId) throw new Error("Missing roomId");
  if(!Number.isFinite(n) || n<1 || n>90) throw new Error("Invalid n (1..90)");

  return lock_(()=>{
    init_();

    const st = getState_(roomId);
    st.roomStatus = String(getRoomStatus_(roomId) || st.roomStatus || "");

    if(String(st.roomStatus).trim().toLowerCase() === "closed"){
      return { ok:false, error:"Room is closed", roomId };
    }

    // check already drawn via state
    if((st.draws || []).some(d => Number(d.n) === n)){
      return { ok:false, error:"Number already drawn", roomId, n };
    }

    const drawIndex = Number(st.lastDrawIndex||0) + 1;
    const ts = nowISO_();

    // audit log
    const shD = getOrCreateSheet_(CFG.SHEETS.DRAWS);
    shD.appendRow([roomId, n, drawIndex, ts]);

    // update state
    st.draws = Array.isArray(st.draws) ? st.draws : [];
    st.draws.push({ roomId, n, drawIndex, at: ts });
    st.lastDrawIndex = drawIndex;

    if(drawIndex >= 90){
      setRoomStatus_(roomId, "closed");
      st.roomStatus = "closed";
    }else{
      st.roomStatus = String(getRoomStatus_(roomId) || st.roomStatus || "");
    }

    saveStateToSheet_(st);

    return { ok:true, roomId, n, drawIndex, at: ts };
  });
}

// -------------------- Delta (tabellone) --------------------
function delta_(p){
  const roomId = roomKey_(p.roomId);
  const sinceDrawIndex = Math.max(0, Number(p.sinceDrawIndex || 0) || 0);
  const sinceEventAt = String(p.sinceEventAt || "").trim(); // ISO string, "" = dall'inizio

  if(!roomId) throw new Error("Missing roomId");
  init_();

  const st = getState_(roomId);
  st.roomStatus = String(getRoomStatus_(roomId) || st.roomStatus || "");

  // newDraws da state (veloce)
  const draws = Array.isArray(st.draws) ? st.draws : [];
  const newDraws = draws.filter(d => Number(d.drawIndex||0) > sinceDrawIndex)
                        .map(d => ({ roomId, n:Number(d.n), drawIndex:Number(d.drawIndex), at:String(d.at||"") }))
                        .sort((a,b)=>a.drawIndex-b.drawIndex);

  // newEvents:
  // - se sinceEventAt == "" => bootstrap: leggi TUTTI gli eventi PRIZE dal foglio (raro, solo quando tabellone ricarica)
  // - altrimenti usa tail se copre la finestra, altrimenti fallback su scan (raro)
  let newEvents = [];

  if(!sinceEventAt){
    const shE = getOrCreateSheet_(CFG.SHEETS.EVENTS);
    const lastE = shE.getLastRow();
    if(lastE >= 2){
      const rows = shE.getRange(2,1,lastE-1,8).getValues();
      for(const r of rows){
        if(String(r[0]||"").toUpperCase() !== roomId) continue;
        if(String(r[2]||"") !== "PRIZE") continue;

        const at = String(r[1]||"");
        newEvents.push({
          at,
          type: "PRIZE",
          playerId: String(r[3]||""),
          name: String(r[4]||""),
          cardIndex: Number(r[5]||0),
          prize: String(r[6]||""),
          payload: safeJson_(String(r[7]||"{}"))
        });
      }
      newEvents.sort((a,b)=> (a.at < b.at ? -1 : (a.at > b.at ? 1 : 0)));
    }

    // aggiorna state tail (utile dopo bootstrap)
    const tail = newEvents.slice(-CFG.LIMITS.EVENTS_TAIL_MAX);
    st.eventsTail = tail;
    st.eventsTailFromAt = tail.length ? String(tail[0].at||"") : "";
    st.lastEventAt = newEvents.length ? String(newEvents[newEvents.length-1].at||"") : "";
    saveStateToSheet_(st);

  } else {
    const tailFrom = String(st.eventsTailFromAt||"");
    const tail = Array.isArray(st.eventsTail) ? st.eventsTail : [];

    if(tailFrom && sinceEventAt >= tailFrom){
      newEvents = tail.filter(e => String(e.at||"") > sinceEventAt);
    } else {
      // fallback scan (raro)
      const shE = getOrCreateSheet_(CFG.SHEETS.EVENTS);
      const lastE = shE.getLastRow();
      if(lastE >= 2){
        const rows = shE.getRange(2,1,lastE-1,8).getValues();
        for(const r of rows){
          if(String(r[0]||"").toUpperCase() !== roomId) continue;
          if(String(r[2]||"") !== "PRIZE") continue;

          const at = String(r[1]||"");
          if(at && at <= sinceEventAt) continue;

          newEvents.push({
            at,
            type: "PRIZE",
            playerId: String(r[3]||""),
            name: String(r[4]||""),
            cardIndex: Number(r[5]||0),
            prize: String(r[6]||""),
            payload: safeJson_(String(r[7]||"{}"))
          });
        }
        newEvents.sort((a,b)=> (a.at < b.at ? -1 : (a.at > b.at ? 1 : 0)));
      }
    }
  }

  const lastDrawIndex = newDraws.length ? newDraws[newDraws.length-1].drawIndex : sinceDrawIndex;
  const lastEventAt = newEvents.length ? newEvents[newEvents.length-1].at : sinceEventAt;

  return {
    ok:true,
    roomId,
    roomStatus: String(st.roomStatus || ""),
    newDraws,
    newEvents,
    lastDrawIndex,
    lastEventAt
  };
}

// -------------------- MarksState / PrizesState (O(1) state) --------------------
function getMarksStateSet_(roomId, playerId, cardIndex){
  const rid = roomKey_(roomId);
  const pid = String(playerId||"").trim().toUpperCase();
  const cix = Number(cardIndex);
  const ck = ckMarks_(rid,pid,cix);
  const cached = cacheGetJson_(ck);
  if(cached && cached.markedCsv != null){
    return new Set(String(cached.markedCsv).split(",").filter(Boolean).map(x=>Number(x)));
  }

  const sh = getOrCreateSheet_(CFG.SHEETS.MARKS_STATE);
  const key = key3_(rid,pid,cix);
  const rowIndex = findRowByExact_(sh, 1, key);

  if(rowIndex){
    const row = sh.getRange(rowIndex,1,1,6).getValues()[0];
    const csv = String(row[4]||"");
    cachePutJson_(ck, { markedCsv: csv });
    return new Set(csv.split(",").filter(Boolean).map(x=>Number(x)));
  }

  // bootstrap (se stai migrando a metà partita): ricostruisci una volta dal log Marks
  const boot = bootstrapMarksFromLog_(rid,pid,cix);
  saveMarksStateSet_(rid,pid,cix,boot);
  return boot;
}

function saveMarksStateSet_(roomId, playerId, cardIndex, set){
  const rid = roomKey_(roomId);
  const pid = String(playerId||"").trim().toUpperCase();
  const cix = Number(cardIndex);
  const sh = getOrCreateSheet_(CFG.SHEETS.MARKS_STATE);
  const key = key3_(rid,pid,cix);

  const csv = [...set].filter(n=>Number.isFinite(n)).sort((a,b)=>a-b).join(",");
  const rowIndex = findRowByExact_(sh, 1, key);
  const out = [key, rid, pid, cix, csv, nowISO_()];

  if(rowIndex){
    sh.getRange(rowIndex,1,1,out.length).setValues([out]);
  }else{
    sh.appendRow(out);
  }
  cachePutJson_(ckMarks_(rid,pid,cix), { markedCsv: csv });
}

function bootstrapMarksFromLog_(roomId, playerId, cardIndex){
  const rid = roomKey_(roomId);
  const pid = String(playerId||"").trim().toUpperCase();
  const cix = Number(cardIndex);

  const shM = getOrCreateSheet_(CFG.SHEETS.MARKS);
  const last = shM.getLastRow();
  const lastToggle = new Map();

  if(last >= 2){
    const rows = shM.getRange(2,1,last-1,6).getValues();
    for(const r of rows){
      if(String(r[0])!==rid) continue;
      if(String(r[1])!==pid) continue;
      if(Number(r[2])!==cix) continue;
      const nn = Number(r[3]);
      const mk = Number(r[4])===1;
      lastToggle.set(nn, mk);
    }
  }
  return new Set([...lastToggle.entries()].filter(([,mk])=>mk).map(([nn])=>nn));
}

function getPrizesState_(roomId, playerId, cardIndex){
  const rid = roomKey_(roomId);
  const pid = String(playerId||"").trim().toUpperCase();
  const cix = Number(cardIndex);
  const ck = ckPrizes_(rid,pid,cix);
  const cached = cacheGetJson_(ck);
  if(cached && cached.prizesJson != null){
    const obj = safeJson_(String(cached.prizesJson||"{}"));
    return obj && typeof obj === "object" ? obj : {};
  }

  const sh = getOrCreateSheet_(CFG.SHEETS.PRIZES_STATE);
  const key = key3_(rid,pid,cix);
  const rowIndex = findRowByExact_(sh, 1, key);

  if(rowIndex){
    const row = sh.getRange(rowIndex,1,1,6).getValues()[0];
    const pj = String(row[4]||"{}");
    cachePutJson_(ck, { prizesJson: pj });
    const obj = safeJson_(pj);
    return (obj && typeof obj === "object") ? obj : {};
  }

  // bootstrap (migrazione)
  const boot = bootstrapPrizesFromLog_(rid,pid,cix);
  savePrizesState_(rid,pid,cix,boot);
  return boot;
}

function savePrizesState_(roomId, playerId, cardIndex, obj){
  const rid = roomKey_(roomId);
  const pid = String(playerId||"").trim().toUpperCase();
  const cix = Number(cardIndex);
  const sh = getOrCreateSheet_(CFG.SHEETS.PRIZES_STATE);
  const key = key3_(rid,pid,cix);

  const pj = JSON.stringify(obj || {});
  const rowIndex = findRowByExact_(sh, 1, key);
  const out = [key, rid, pid, cix, pj, nowISO_()];

  if(rowIndex){
    sh.getRange(rowIndex,1,1,out.length).setValues([out]);
  }else{
    sh.appendRow(out);
  }
  cachePutJson_(ckPrizes_(rid,pid,cix), { prizesJson: pj });
}

function bootstrapPrizesFromLog_(roomId, playerId, cardIndex){
  const rid = roomKey_(roomId);
  const pid = String(playerId||"").trim().toUpperCase();
  const cix = Number(cardIndex);

  const sh = getOrCreateSheet_(CFG.SHEETS.PRIZES);
  const last = sh.getLastRow();
  const out = {};

  if(last >= 2){
    const rows = sh.getRange(2,1,last-1,5).getValues();
    for(const r of rows){
      if(String(r[0])!==rid) continue;
      if(String(r[1])!==pid) continue;
      if(Number(r[2])!==cix) continue;
      const prize = String(r[3]||"").trim();
      if(prize) out[prize] = 1;
    }
  }
  return out;
}

// -------------------- Marks + prizes (cartelle) --------------------
function getDrawIndexByNumber_(st){
  // crea una mappa veloce n->drawIndex partendo dai draws in state (max 90)
  const map = {};
  const draws = Array.isArray(st.draws) ? st.draws : [];
  for(const d of draws){
    const nn = Number(d.n);
    const di = Number(d.drawIndex)||0;
    if(Number.isFinite(nn) && Number.isFinite(di)) map[nn] = di;
  }
  return map;
}

function mark_(p){
  const roomId = roomKey_(p.roomId);
  const playerId = String(p.playerId || "").trim().toUpperCase();
  const cardIndex = Number(p.cardIndex);
  const n = Number(p.n);
  const marked = String(p.marked||"1") === "1";

  if(!roomId) throw new Error("Missing roomId");
  if(!playerId) throw new Error("Missing playerId");
  if(!Number.isFinite(cardIndex)) throw new Error("Invalid cardIndex");
  if(!Number.isFinite(n) || n<1 || n>90) throw new Error("Invalid n (1..90)");

  return lock_(()=>{
    init_();

    // stato room
    const st = getState_(roomId);
    st.roomStatus = String(getRoomStatus_(roomId) || st.roomStatus || "");

    const drawIndexByNumber = getDrawIndexByNumber_(st);
    if(!drawIndexByNumber[n]){
      return {ok:false, error:"Number not drawn yet", roomId, n};
    }

    // card
    const card = getCard_(roomId, playerId, cardIndex);
    if(!card){
      return {ok:false, error:"Card not registered", roomId, playerId, cardIndex};
    }
    if(!card.numbersSet.has(n)){
      return {ok:false, error:"Number not in card", roomId, n, cardIndex};
    }

    // audit log mark (append-only)
    const shM = getOrCreateSheet_(CFG.SHEETS.MARKS);
    shM.appendRow([roomId, playerId, cardIndex, n, marked ? 1 : 0, nowISO_()]);

    // marks state (O(1))
    const markedSet = getMarksStateSet_(roomId, playerId, cardIndex);
    if(marked) markedSet.add(n); else markedSet.delete(n);
    saveMarksStateSet_(roomId, playerId, cardIndex, markedSet);

    // player name (per event)
    const player = getOrCreatePlayer_(roomId, playerId, String(p.name||"").trim() || null);

    // prizes state (O(1))
    const prizesState = getPrizesState_(roomId, playerId, cardIndex);

    const { newly } = computeAndRecordPrizesFast_(
      st, drawIndexByNumber,
      roomId, playerId, player.name, cardIndex, card.grid, n,
      prizesState
    );

    // salva prizes state se cambiato
    if(newly.length){
      savePrizesState_(roomId, playerId, cardIndex, prizesState);
      saveStateToSheet_(st);
    }

    return {ok:true, roomId, playerId, name: player.name, cardIndex, n, marked, newly};
  });
}

function getOrCreatePlayer_(roomId, playerId, nameOrNull){
  const shP = getOrCreateSheet_(CFG.SHEETS.PLAYERS);
  const last = shP.getLastRow();
  let name = String(nameOrNull || "").trim();

  if(last >= 2){
    const rows = shP.getRange(2,1,last-1,5).getValues();
    for(let i=0;i<rows.length;i++){
      const rid = String(rows[i][0]||"").toUpperCase();
      const pid = String(rows[i][1]||"").toUpperCase();
      if(rid===roomId && pid===playerId){
        if(!name) name = String(rows[i][2] || ("Giocatore-"+playerId));
        shP.getRange(i+2, 3).setValue(name);
        shP.getRange(i+2, 5).setValue(nowISO_());
        return {roomId, playerId, name};
      }
    }
  }

  if(!name) name = "Giocatore-" + playerId;
  shP.appendRow([roomId, playerId, name, nowISO_(), nowISO_()]);
  return {roomId, playerId, name};
}

function computeAndRecordPrizesFast_(
  st, drawIndexByNumber,
  roomId, playerId, name, cardIndex, grid, triggerN,
  prizesState
){
  const rowPrizes = [
    {k:2, prize:"AMBO"},
    {k:3, prize:"TERNO"},
    {k:4, prize:"QUATERNA"},
    {k:5, prize:"CINQUINA"},
  ];
  const newly = [];

  const markedSet = getMarksStateSet_(roomId, playerId, cardIndex); // già aggiornato

  // righe
  for(let r=0;r<3;r++){
    const rowNums = (grid[r]||[]).filter(v=>v!==null && v!=="" && v!==undefined).map(Number);
    const hitNums = rowNums.filter(nn=>markedSet.has(nn));

    rowPrizes.forEach(({k,prize})=>{
      if(hitNums.length >= k){
        if(!prizesState[prize]){
          const di = hitNums.reduce((mx, nn)=> Math.max(mx, Number(drawIndexByNumber[nn]||0)), 0);
          const candidates = hitNums.filter(nn => Number(drawIndexByNumber[nn]||0) === di);
          const trig = candidates.includes(Number(triggerN)) ? Number(triggerN) : (candidates[0] || Number(triggerN) || null);

          const payload = {
            row: r+1,
            hit: hitNums.length,
            marked: [...markedSet].sort((a,b)=>a-b),
            winNumbers: hitNums.slice().sort((a,b)=>a-b),
            drawIndex: di,
            triggerN: trig
          };

          recordPrize_(st, roomId, playerId, name, cardIndex, prize, payload);
          prizesState[prize] = 1;
          newly.push({prize, winNumbers: payload.winNumbers, drawIndex: di, triggerN: trig});
        }
      }
    });
  }

  // tombola
  if(markedSet.size >= 15){
    const prize = "TOMBOLA";
    if(!prizesState[prize]){
      const wn = [...markedSet].sort((a,b)=>a-b);
      const di = wn.reduce((mx, nn)=> Math.max(mx, Number(drawIndexByNumber[nn]||0)), 0);
      const candidates = wn.filter(nn => Number(drawIndexByNumber[nn]||0) === di);
      const trig = candidates.includes(Number(triggerN)) ? Number(triggerN) : (candidates[0] || Number(triggerN) || null);

      const payload = {
        hit: markedSet.size,
        marked: [...markedSet].sort((a,b)=>a-b),
        winNumbers: wn,
        drawIndex: di,
        triggerN: trig
      };

      recordPrize_(st, roomId, playerId, name, cardIndex, prize, payload);
      prizesState[prize] = 1;
      newly.push({prize, winNumbers: wn, drawIndex: di, triggerN: trig});
    }
  }

  return { newly };
}

function recordPrize_(st, roomId, playerId, name, cardIndex, prize, payload){
  const shPr = getOrCreateSheet_(CFG.SHEETS.PRIZES);
  const shEv = getOrCreateSheet_(CFG.SHEETS.EVENTS);
  const ts = nowISO_();

  const p = payload || {};
  if(!Array.isArray(p.winNumbers)) p.winNumbers = [];
  if(!Array.isArray(p.marked)) p.marked = [];
  if(!Number.isFinite(Number(p.drawIndex))) p.drawIndex = 0;
  if(!Number.isFinite(Number(p.triggerN))) p.triggerN = null;

  // log
  shPr.appendRow([roomId, playerId, cardIndex, prize, ts]);
  shEv.appendRow([roomId, ts, "PRIZE", playerId, name, cardIndex, prize, JSON.stringify(p)]);

  // aggiorna state tail (delta veloce)
  const ev = {
    at: ts,
    type: "PRIZE",
    playerId,
    name,
    cardIndex: Number(cardIndex)||0,
    prize: String(prize||""),
    payload: p
  };
  pushEventToStateTail_(st, ev);
  st.lastEventAt = ts;
}
