<!-- cartelle.html (NEW) ‚Äî Mobile-first ‚Ä¢ Google Apps Script backend ‚Ä¢ 50 giocatori friendly
  Backend atteso (azioni JSONP):
  - action=join         {roomId, playerId, name} -> {ok, name}
  - action=getCards     {roomId, playerId} -> {ok, cards:[{cardIndex, grid}]}
  - action=registerCards{roomId, playerId, cardsJson} -> {ok}
  - action=getMarks     {roomId, playerId} -> {ok, marks:[{cardIndex, numbers:[...] }]}
  - action=mark         {roomId, playerId, cardIndex, n, marked} -> {ok, newly:[{prize, winNumbers, drawIndex}]?}
  - action=delta        {roomId, sinceDrawRow, sincePrizeRow} -> {ok, roomStatus, roomEpoch?, lastDrawRow, lastPrizeRow, newDraws[], newPrizes[]}
    (qui usiamo delta solo per estrazioni, per evidenziare i numeri gi√† usciti e mostrare ‚ÄúUltimo/Conteggio‚Äù)
-->
<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Cartelle ‚Äì Tombola Natalizia</title>

  <style>
    :root{
      --bgA:#ff1e3a;
      --bgB:#c4001a;
      --gold:#ffcc2e;

      --txt:#141414;
      --stroke: rgba(255,255,255,.78);
      --shadow: 0 18px 40px rgba(0,0,0,.14);
      --r: 18px;

      --barH: 64px;

      --cardPad: 5px;
      --gridGap: 1px;
      --cellH: 34px;
      --titleF: 12px;
      --santaF: 22px;

      --numMin: 16px;
      --numVw: 6.2vw;
      --numMax: 26px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height: 100svh;
      color:var(--txt);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1000px 700px at 10% 10%, rgba(255,255,255,.30) 0%, transparent 58%),
        radial-gradient(800px 600px at 90% 12%, rgba(255,204,46,.35) 0%, transparent 55%),
        radial-gradient(900px 700px at 70% 90%, rgba(255,255,255,.22) 0%, transparent 62%),
        linear-gradient(135deg, var(--bgA), var(--bgB));
      overflow-x:hidden;
    }

    .topbar{
      position: fixed;
      left: 0; right: 0; top: 0;
      height: var(--barH);
      padding: calc(env(safe-area-inset-top) + 8px) 12px 10px;
      display:flex;
      justify-content:center;
      align-items:flex-end;
      z-index: 50;
      transition: transform .22s ease;
      transform: translateY(0);
    }
    .topbar.hidden{ transform: translateY(-120%); }

    .topbarInner{
      width: min(860px, 100%);
      border: 1px solid rgba(255,255,255,.65);
      background: rgba(255,255,255,.88);
      border-radius: 999px;
      box-shadow: 0 14px 30px rgba(0,0,0,.16);
      padding: 8px;
      display:flex;
      gap: 10px;
      justify-content: space-between;
      align-items:center;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    .leftRow{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .rightRow{ display:flex; gap:10px; align-items:center; }

    .qtyBtn{
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.94);
      color:#111;
      border-radius: 999px;
      padding: 10px 14px;
      min-width: 54px;
      font-weight: 1000;
      font-size: 16px;
      line-height: 1;
      box-shadow: 0 10px 22px rgba(0,0,0,.10);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor:pointer;
    }
    .qtyBtn.active{
      background: linear-gradient(180deg, #ffe17b, #ffcc2e);
      border-color: rgba(0,0,0,.18);
    }

    .chipInfo{
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.94);
      color:#111;
      border-radius: 999px;
      padding: 10px 12px;
      font-weight: 1000;
      box-shadow: 0 10px 22px rgba(0,0,0,.10);
      white-space: nowrap;
      font-size: 13px;
    }
    .chipInfo b{ font-size: 14px; }

    .userBtn{
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.94);
      color:#111;
      border-radius: 999px;
      padding: 10px 12px;
      min-width: 54px;
      font-weight: 1000;
      font-size: 18px;
      line-height: 1;
      box-shadow: 0 10px 22px rgba(0,0,0,.10);
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      max-width: 260px;
    }
    .userMini{
      font-size: 12px;
      color: rgba(0,0,0,.60);
      font-weight: 900;
      max-width: 160px;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .wrap{
      width: 100%;
      padding: calc(var(--barH) + env(safe-area-inset-top) + 10px) 10px 18px;
      display:flex;
      justify-content:center;
    }
    .cards{
      width: min(980px, 100%);
      display:grid;
      gap: 10px;
      grid-template-columns: 1fr;
      align-items: start;
    }

    .tcard{
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.90);
      border-radius: var(--r);
      padding: var(--cardPad);
      overflow:hidden;
      box-shadow: var(--shadow);
    }
    .tTitle{
      margin: 0 0 3px;
      display:grid;
      grid-template-columns: 1fr auto 1fr;
      align-items:center;
      font-size: var(--titleF);
      font-weight: 1000;
      color:#111;
    }
    .tTitleText{ justify-self:center; }
    .tSanta{
      justify-self:end;
      font-size: var(--santaF);
      line-height: 1;
      color: rgba(0,0,0,.55);
    }
    .tSpacer{ display:block; }

    .grid9{
      display:grid;
      grid-template-columns: repeat(9, 1fr);
      gap: var(--gridGap);
    }

    .cell{
      height: var(--cellH);
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.96);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 1000;
      user-select:none;
      position:relative;
      cursor:pointer;
      color:#0b0b0b;
      font-size: clamp(var(--numMin), var(--numVw), var(--numMax));
      letter-spacing: .2px;
      box-shadow: 0 8px 18px rgba(0,0,0,.07);
    }
    .cell.empty{
      background: rgba(255,255,255,.72);
      cursor:default;
      border-color: rgba(0,0,0,.06);
      box-shadow:none;
    }

    /* numero gi√† estratto */
    .cell.drawn{
      background: linear-gradient(180deg, rgba(10,143,63,.26), rgba(10,143,63,.12));
      border-color: rgba(10,143,63,.45);
      box-shadow: 0 10px 22px rgba(10,143,63,.10);
    }

    /* marcato dal giocatore */
    .cell.marked{
      background: linear-gradient(180deg, rgba(215,0,27,.30), rgba(215,0,27,.14));
      border-color: rgba(215,0,27,.62);
      box-shadow: 0 12px 26px rgba(215,0,27,.14);
    }

    /* se √® sia estratto che marcato, enfatizzo */
    .cell.drawn.marked{
      box-shadow:
        0 12px 26px rgba(215,0,27,.14),
        0 10px 22px rgba(10,143,63,.10);
    }

    .toast{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 18px;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.10);
      box-shadow: 0 14px 30px rgba(0,0,0,.18);
      border-radius: 999px;
      padding: 10px 14px;
      font-weight: 900;
      z-index: 80;
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease;
      max-width: min(760px, calc(100% - 24px));
      text-align:center;
    }
    .toast.show{ opacity: 1; }

    .overlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.35);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 90;
      padding: 18px;
    }
    .overlay.show{ display:flex; }
    .modal{
      width: min(520px, 100%);
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(255,255,255,.55);
      border-radius: 22px;
      box-shadow: 0 20px 55px rgba(0,0,0,.25);
      padding: 16px;
    }
    .modal h3{ margin:0 0 10px; }
    .modal p{ margin:0 0 10px; color:rgba(0,0,0,.70); }
    .row{ display:flex; gap:10px; align-items:center; }
    input{
      flex:1;
      border-radius: 14px;
      border:1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.95);
      padding: 12px 12px;
      font-weight: 900;
      outline:none;
    }
    .mBtn{
      border-radius: 14px;
      border:1px solid rgba(0,0,0,.12);
      padding: 12px 12px;
      font-weight: 1000;
      cursor:pointer;
      background: rgba(255,255,255,.92);
      box-shadow: 0 14px 30px rgba(0,0,0,.14);
      min-width: 120px;
    }
    .mBtn.primary{ background: linear-gradient(180deg, #ffe17b, #ffcc2e); }

    /* Snow */
    .snow{ position:fixed; inset:0; pointer-events:none; overflow:hidden; z-index:0; }
    .flake{
      position:absolute; top:-10px;
      width:6px; height:6px; border-radius:50%;
      background: rgba(255,255,255,.95);
      box-shadow: 0 0 14px rgba(255,255,255,.45);
      opacity:.85;
      animation: fall linear infinite;
    }
    .flake.gold{
      background: rgba(255,204,46,.95);
      box-shadow: 0 0 14px rgba(255,204,46,.45);
      opacity:.8;
    }
    @keyframes fall{ to{ transform: translate3d(var(--dx), 110svh, 0); } }
  </style>
</head>

<body>
  <div class="snow" id="snow"></div>

  <div class="toast" id="toast"></div>

  <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-label="Nome giocatore">
    <div class="modal">
      <h3>üë§ Nome giocatore</h3>
      <p>Inserisci il tuo nome (opzionale). Se lasci vuoto, resta un nome univoco automatico.</p>
      <div class="row">
        <input id="nameInput" placeholder="Es. Mario" />
        <button class="mBtn primary" id="saveName">Salva</button>
      </div>
      <div style="margin-top:10px;display:flex;justify-content:flex-end">
        <button class="mBtn" id="closeModal">Chiudi</button>
      </div>
    </div>
  </div>

  <div class="topbar" id="topbar">
    <div class="topbarInner">
      <div class="leftRow" aria-label="Numero cartelle">
        <div id="qtyRow" style="display:flex;gap:10px;align-items:center">
          <button class="qtyBtn" data-n="1">1</button>
          <button class="qtyBtn" data-n="2">2</button>
          <button class="qtyBtn" data-n="3">3</button>
          <button class="qtyBtn active" data-n="4">4</button>
        </div>

        <div class="chipInfo" title="Room">
          Room <b id="roomBadge">‚Äî</b>
        </div>
      </div>

      <div class="rightRow">
        <div class="chipInfo" title="Ultimo estratto">
          Ultimo <b id="lastDraw">‚Äî</b>
        </div>
        <div class="chipInfo" title="Conteggio estratti">
          <b id="countDraw">0</b>/90
        </div>

        <button class="userBtn" id="userBtn" title="Imposta nome">
          üë§ <span class="userMini" id="userMini">Anonimo</span>
        </button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="cards" id="cards"></div>
  </div>

  <script>
    // ====== CONFIG ======
    const API_BASE = "https://script.google.com/macros/s/AKfycbyM0N-kMkCqD54L-LRCdjALMBry5i1wsdKlpWI8AezXIdQoS53Jp6K6Jguv9MgEbigA/exec";
    const POLL_MS = 2500; // 50 giocatori: pi√π leggero di 1s

    function getRoomId(){
      const url = new URL(location.href);
      const q = (url.searchParams.get("room") || "").trim().toUpperCase();
      const ls = (localStorage.getItem("tombola_roomId") || "").trim().toUpperCase();
      let room = q || ls;
      if(!room){
        room = (prompt("Inserisci il codice ROOM (es. R636SQ):") || "").trim().toUpperCase();
      }
      if(room) localStorage.setItem("tombola_roomId", room);
      return room || null;
    }

    function jsonp(action, params={}, timeoutMs=12000){
      return new Promise((resolve, reject)=>{
        const cb = "cb_" + Math.random().toString(36).slice(2);
        const qs = new URLSearchParams({ action, ...params, callback: cb, nocache: Date.now() }).toString();
        const s = document.createElement("script");
        const t = setTimeout(()=>{ cleanup(); reject(new Error("Timeout")); }, timeoutMs);

        function cleanup(){
          clearTimeout(t);
          if(window[cb]) delete window[cb];
          if(s && s.parentNode) s.parentNode.removeChild(s);
        }

        window[cb] = (data)=>{ cleanup(); resolve(data); };
        s.onerror = ()=>{ cleanup(); reject(new Error("Network error")); };
        s.src = API_BASE + "?" + qs;
        document.body.appendChild(s);
      });
    }

    // ====== TOAST ======
    const toast = document.getElementById("toast");
    let toastT = null;
    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      clearTimeout(toastT);
      toastT = setTimeout(()=>toast.classList.remove("show"), 2200);
    }

    // ====== MODAL NOME ======
    const overlay = document.getElementById("overlay");
    const userBtn = document.getElementById("userBtn");
    const userMini = document.getElementById("userMini");
    const nameInput = document.getElementById("nameInput");

    function openModal(){
      overlay.classList.add("show");
      nameInput.value = (localStorage.getItem(nameKey()) || "").trim();
      setTimeout(()=>nameInput.focus(), 50);
    }
    function closeModal(){ overlay.classList.remove("show"); }

    document.getElementById("closeModal").onclick = closeModal;
    overlay.addEventListener("click", (e)=>{ if(e.target === overlay) closeModal(); });
    userBtn.onclick = openModal;

    // ====== ROOM / PLAYER ======
    const roomId = getRoomId();
    document.getElementById("roomBadge").textContent = roomId || "‚Äî";

    function pidKey(){ return "tombola_playerId_" + roomId; }
    function nameKey(){ return "tombola_playerName_" + roomId; }

    function getPlayerId(){
      let pid = (localStorage.getItem(pidKey()) || "").trim().toUpperCase();
      if(!pid){
        pid = Math.random().toString(16).slice(2,10).toUpperCase();
        localStorage.setItem(pidKey(), pid);
      }
      return pid;
    }
    function getPlayerName(){ return (localStorage.getItem(nameKey()) || "").trim(); }

    async function join(){
      const playerId = getPlayerId();
      const name = getPlayerName();
      const res = await jsonp("join", { roomId, playerId, name });
      if(res && res.ok){
        if(!getPlayerName()){
          localStorage.setItem(nameKey(), res.name || "");
        }
        userMini.textContent = (localStorage.getItem(nameKey()) || "Anonimo");
        return res;
      }
      throw new Error(res && res.error ? res.error : "join failed");
    }

    document.getElementById("saveName").onclick = async ()=>{
      const val = nameInput.value.trim();
      localStorage.setItem(nameKey(), val);
      userMini.textContent = (val || "Anonimo");
      closeModal();
      try{
        const res = await jsonp("join", { roomId, playerId: getPlayerId(), name: val });
        if(res && res.ok) showToast("Nome aggiornato ‚úÖ");
        else showToast("Errore nome ‚ùå");
      }catch(e){
        showToast("Errore rete ‚ùå");
      }
    };

    // ====== SNOW ======
    const snow = document.getElementById('snow');
    const N = 28;
    for(let i=0;i<N;i++){
      const f = document.createElement('div');
      const isGold = Math.random() < 0.20;
      f.className = 'flake' + (isGold ? ' gold' : '');
      const x = Math.random()*100;
      const size = 3 + Math.random()*5;
      const dur = 9 + Math.random()*14;
      const dx = (Math.random()*2-1) * 140 + "px";
      f.style.left = x + "vw";
      f.style.width = size + "px";
      f.style.height = size + "px";
      f.style.animationDuration = dur + "s";
      f.style.setProperty('--dx', dx);
      f.style.opacity = (0.30 + Math.random()*0.55).toFixed(2);
      f.style.filter = `blur(${(Math.random()*0.6).toFixed(2)}px)`;
      f.style.animationDelay = (-Math.random()*dur) + "s";
      snow.appendChild(f);
    }

    // ====== GENERATORE CARTELLA ======
    function rng(){ return Math.random(); }
    function pickUnique(arr, k){
      const a = arr.slice();
      const out = [];
      for(let i=0;i<k;i++){
        const idx = Math.floor(rng()*a.length);
        out.push(a.splice(idx,1)[0]);
      }
      return out;
    }

    const COLS = [
      {min:1,max:9},{min:10,max:19},{min:20,max:29},{min:30,max:39},{min:40,max:49},
      {min:50,max:59},{min:60,max:69},{min:70,max:79},{min:80,max:90},
    ];

    function makeCard(){
      let counts = Array(9).fill(1);
      let remaining = 6;
      while(remaining > 0){
        const c = Math.floor(rng()*9);
        if(counts[c] < 3){ counts[c]++; remaining--; }
      }

      const colNums = counts.map((cnt, ci)=>{
        const range = [];
        for(let n=COLS[ci].min; n<=COLS[ci].max; n++) range.push(n);
        return pickUnique(range, cnt).sort((a,b)=>a-b);
      });

      for(let attempt=0; attempt<250; attempt++){
        const rowCounts = [0,0,0];
        const placement = Array(9).fill(null).map(()=>[]);

        for(let ci=0; ci<9; ci++){
          const cnt = colNums[ci].length;
          let rows;
          if(cnt === 3) rows = [0,1,2];
          else if(cnt === 2){
            const order = [0,1,2].sort((a,b)=>rowCounts[a]-rowCounts[b] || (rng()-0.5));
            rows = [order[0], order[1]];
          } else {
            const order = [0,1,2].sort((a,b)=>rowCounts[a]-rowCounts[b] || (rng()-0.5));
            rows = [order[0]];
          }
          for(const r of rows){
            placement[ci].push(r);
            rowCounts[r]++;
          }
        }

        if(rowCounts[0]===5 && rowCounts[1]===5 && rowCounts[2]===5){
          const grid = Array.from({length:3}, ()=>Array(9).fill(null));
          for(let ci=0; ci<9; ci++){
            const rows = placement[ci].slice().sort((a,b)=>a-b);
            const nums = colNums[ci];
            for(let i=0;i<rows.length;i++){
              grid[rows[i]][ci] = nums[i];
            }
          }
          return grid;
        }
      }
      return makeCard();
    }

    // ====== UI / SIZING ======
    const root = document.documentElement;
    const cardsWrap = document.getElementById('cards');
    const topbar = document.getElementById('topbar');

    function applyMaxSizingForN(n){
      const barH = topbar.getBoundingClientRect().height || 64;
      const vh = window.innerHeight;
      const vw = Math.min(window.innerWidth, cardsWrap.getBoundingClientRect().width || window.innerWidth);

      const wrapPadX = 10 * 2;
      const usableW = Math.max(260, vw - wrapPadX);

      const outerGap = 10;
      const wrapPadTop = 10;
      const wrapPadBottom = 18;
      const usableH = vh - barH - wrapPadTop - wrapPadBottom - 12;

      const gap = 1;
      const pad = 5;

      const titleF = 12;
      const titleH = Math.ceil(titleF * 1.2) + 3;

      const cellByW = Math.floor((usableW - (gap * 8) - 2) / 9);
      let cellH = Math.max(18, Math.min(60, cellByW));

      const maxCardH = Math.floor((usableH - outerGap * (n - 1)) / n);
      const maxGridH = maxCardH - (pad * 2) - titleH;
      const maxCellByH = Math.floor((maxGridH - (gap * 2)) / 3);

      if (Number.isFinite(maxCellByH) && maxCellByH > 0) {
        cellH = Math.min(cellH, Math.max(16, maxCellByH));
      }

      const numMax = Math.max(16, Math.min(42, Math.round(cellH * 0.90)));
      const numMin = Math.max(14, Math.round(numMax * 0.82));

      root.style.setProperty('--gridGap', gap + 'px');
      root.style.setProperty('--cellH', cellH + 'px');
      root.style.setProperty('--cardPad', pad + 'px');
      root.style.setProperty('--titleF', titleF + 'px');
      root.style.setProperty('--santaF', Math.round(titleF * 1.8) + 'px');

      root.style.setProperty('--numMin', numMin + 'px');
      root.style.setProperty('--numMax', numMax + 'px');
      root.style.setProperty('--numVw', '6.2vw');
    }

    // ====== STATE (draws + marks + mapping veloce numero->celle) ======
    const state = {
      roomEpoch: null,
      roomStatus: "open",
      sinceDrawRow: 1,
      sincePrizeRow: 1,

      drawnSet: new Set(),
      lastDrawN: null,

      // marks per cardIndex
      markSets: new Map(), // cardIndex -> Set(numbers)

      // mapping numero -> array di HTMLElement (celle che contengono quel numero)
      numCells: new Map(), // n -> [cellEl...]
    };

    const elLastDraw = document.getElementById("lastDraw");
    const elCountDraw = document.getElementById("countDraw");

    function updateTopInfo_(){
      elLastDraw.textContent = state.lastDrawN ? String(state.lastDrawN) : "‚Äî";
      elCountDraw.textContent = String(state.drawnSet.size);
    }

    function bindNumberCell_(n, el){
      if(!state.numCells.has(n)) state.numCells.set(n, []);
      state.numCells.get(n).push(el);
      // se gi√† estratto, applico subito classe
      if(state.drawnSet.has(n)) el.classList.add("drawn");
    }

    function applyDraw_(n){
      n = Number(n);
      if(!Number.isFinite(n) || n<1 || n>90) return;
      if(state.drawnSet.has(n)) return;
      state.drawnSet.add(n);
      state.lastDrawN = n;

      const list = state.numCells.get(n);
      if(list && list.length){
        for(const el of list) el.classList.add("drawn");
      }
      updateTopInfo_();
    }

    function applyMarksToUI_(){
      for(const [cardIndex, set] of state.markSets.entries()){
        for(const n of set){
          const list = state.numCells.get(n);
          if(!list) continue;
          for(const el of list){
            if(Number(el.dataset.cardIndex) === Number(cardIndex) && Number(el.dataset.n) === Number(n)){
              el.classList.add("marked");
            }
          }
        }
      }
    }

    // ====== RENDER CARDS ======
    function renderCard(container, idx, grid){
      const card = document.createElement('div');
      card.className = "tcard";
      card.innerHTML = `
        <h3 class="tTitle">
          <span class="tSpacer"></span>
          <span class="tTitleText">Cartella ${idx+1}</span>
          <span class="tSanta">üéÑ</span>
        </h3>
      `;

      const g = document.createElement('div');
      g.className = 'grid9';

      const inFlight = new Set(); // evita doppio tap mentre la richiesta mark √® in corso

      grid.flat().forEach((val)=>{
        const c = document.createElement('div');
        const isEmpty = (val == null);
        c.className = 'cell' + (isEmpty ? ' empty' : '');
        c.textContent = isEmpty ? '' : String(val);

        if(!isEmpty){
          c.dataset.n = String(val);
          c.dataset.cardIndex = String(idx);

          bindNumberCell_(Number(val), c);

          c.addEventListener('click', async ()=>{
            const key = `${idx}|${val}`;
            if(inFlight.has(key)) return;

            const markSet = state.markSets.get(idx) || new Set();
            const currentlyMarked = markSet.has(Number(val));
            const willMark = !currentlyMarked;

            // optimistic UI
            if(willMark){
              c.classList.add("marked");
              markSet.add(Number(val));
            }else{
              c.classList.remove("marked");
              markSet.delete(Number(val));
            }
            state.markSets.set(idx, markSet);

            inFlight.add(key);
            try{
              const res = await jsonp("mark", {
                roomId,
                playerId: getPlayerId(),
                cardIndex: idx,
                n: Number(val),
                marked: willMark ? 1 : 0
              });

              if(!res || !res.ok){
                // revert
                if(willMark){
                  c.classList.remove("marked");
                  markSet.delete(Number(val));
                }else{
                  c.classList.add("marked");
                  markSet.add(Number(val));
                }
                state.markSets.set(idx, markSet);
                showToast(res && res.error ? res.error : "Marcatura rifiutata");
                return;
              }

              // toast premi (se presenti)
              if(Array.isArray(res.newly) && res.newly.length){
                const msg = res.newly.map(x=>{
                  const wn = Array.isArray(x.winNumbers) ? x.winNumbers : [];
                  return wn.length ? `${x.prize} (${wn.join(", ")})` : x.prize;
                }).join(" ‚Ä¢ ");
                showToast("üéâ " + msg);
              }
            }catch(e){
              // revert su errore rete
              if(willMark){
                c.classList.remove("marked");
                markSet.delete(Number(val));
              }else{
                c.classList.add("marked");
                markSet.add(Number(val));
              }
              state.markSets.set(idx, markSet);
              showToast("Errore rete ‚ùå");
            }finally{
              inFlight.delete(key);
            }
          }, {passive:true});
        }

        g.appendChild(c);
      });

      card.appendChild(g);
      container.appendChild(card);
    }

    // ====== BACKEND: CARDS + MARKS ======
    async function getCards_(){
      const res = await jsonp("getCards", { roomId, playerId: getPlayerId() });
      if(res && res.ok && Array.isArray(res.cards)) return res.cards;
      return [];
    }

    async function registerCards_(cards){
      const payload = cards.map((grid, i)=>({ cardIndex: i, grid }));
      const res = await jsonp("registerCards", {
        roomId,
        playerId: getPlayerId(),
        cardsJson: JSON.stringify(payload)
      });
      if(!res || !res.ok) throw new Error("registerCards failed");
    }

    async function getMarks_(){
      const res = await jsonp("getMarks", { roomId, playerId: getPlayerId() });
      if(res && res.ok && Array.isArray(res.marks)) return res.marks;
      return [];
    }

    // ====== DELTA POLL (solo estrazioni per UI) ======
    let pollInFlight = false;

    async function pollDelta(force=false){
      if(!roomId) return;
      if(pollInFlight) return;
      pollInFlight = true;
      try{
        const res = await jsonp("delta", {
          roomId,
          sinceDrawRow: state.sinceDrawRow,
          sincePrizeRow: state.sincePrizeRow
        }, 12000);

        if(!res || !res.ok) return;

        // epoch reset (opzionale): se cambia, ricarico
        if(res.roomEpoch != null){
          const ep = String(res.roomEpoch);
          if(state.roomEpoch != null && state.roomEpoch !== ep) location.reload();
          state.roomEpoch = ep;
        }

        if(Number.isFinite(Number(res.lastDrawRow))) state.sinceDrawRow = Number(res.lastDrawRow);
        if(Number.isFinite(Number(res.lastPrizeRow))) state.sincePrizeRow = Number(res.lastPrizeRow);

        state.roomStatus = String(res.roomStatus || state.roomStatus || "open").toLowerCase();

        const nd = Array.isArray(res.newDraws) ? res.newDraws : [];
        if(force && !nd.length && state.drawnSet.size === 0){
          // se force iniziale ma backend non manda nulla, ok: niente estrazioni
        }
        for(const d of nd){
          applyDraw_(d.n);
        }
      }catch(e){
        // silenzioso: non vogliamo stressare 50 client con alert
      }finally{
        pollInFlight = false;
      }
    }

    // ====== GENERA / CARICA ======
    let selectedN = 4;
    let currentGrids = []; // array di grid 3x9

    async function buildUIFromGrids_(grids){
      cardsWrap.innerHTML = "";
      state.numCells.clear();
      state.markSets.clear();

      for(let i=0;i<grids.length;i++){
        renderCard(cardsWrap, i, grids[i]);
      }

      // marks da backend
      try{
        const marks = await getMarks_(); // [{cardIndex, numbers:[...]}]
        for(const m of marks){
          const ci = Number(m.cardIndex);
          const nums = Array.isArray(m.numbers) ? m.numbers : [];
          const set = new Set(nums.map(Number).filter(x=>Number.isFinite(x)));
          state.markSets.set(ci, set);
        }
        applyMarksToUI_();
      }catch(e){}

      updateTopInfo_();
    }

    async function generateNewCards_(){
      applyMaxSizingForN(selectedN);

      const grids = [];
      for(let i=0;i<selectedN;i++) grids.push(makeCard());
      currentGrids = grids;

      await registerCards_(grids);
      await buildUIFromGrids_(grids);
      showToast("Cartelle generate ‚úÖ");
    }

    async function loadOrCreate_(){
      applyMaxSizingForN(selectedN);

      // prova a caricare dal backend
      const existing = await getCards_(); // [{cardIndex, grid}]
      if(existing && existing.length){
        const grids = existing
          .slice()
          .sort((a,b)=>Number(a.cardIndex)-Number(b.cardIndex))
          .map(x=>x.grid);
        currentGrids = grids;
        selectedN = grids.length || selectedN;
        await buildUIFromGrids_(grids);
        return;
      }

      // nessuna cartella: ne creo di nuove
      await generateNewCards_();
    }

    // ====== QTY BUTTONS ======
    const qtyRow = document.getElementById('qtyRow');
    qtyRow.addEventListener('click', async (e)=>{
      const btn = e.target.closest('button[data-n]');
      if(!btn) return;

      const n = parseInt(btn.dataset.n, 10);
      if(!Number.isFinite(n) || n<1 || n>4) return;

      // se cambia quantit√†, rigenero e rimpiazzo (nuovo progetto, ok)
      selectedN = n;

      qtyRow.querySelectorAll('.qtyBtn').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');

      try{
        await generateNewCards_();
      }catch(e){
        showToast("Errore salvataggio cartelle ‚ùå");
      }
    });

    // ====== TOPBAR HIDE/SHOW ======
    let lastY = window.scrollY;
    let barHidden = false;
    function setBarHidden(hidden){
      barHidden = hidden;
      topbar.classList.toggle('hidden', hidden);
    }
    window.addEventListener('scroll', ()=>{
      const y = window.scrollY;
      const dy = y - lastY;
      lastY = y;

      if(y < 10){ setBarHidden(false); return; }
      if(dy > 6 && !barHidden) setBarHidden(true);
      if(dy < -6 && barHidden) setBarHidden(false);
    }, {passive:true});

    window.addEventListener('touchstart', (e)=>{
      const t = e.touches && e.touches[0];
      if(!t) return;
      if(t.clientY < 80) setBarHidden(false);
    }, {passive:true});

    window.addEventListener('resize', ()=>{
      applyMaxSizingForN(selectedN);
    }, {passive:true});

    // ====== BOOT ======
    (async ()=>{
      if(!roomId){
        showToast("Room mancante ‚ùå");
        return;
      }

      try{
        await join();
        userMini.textContent = (localStorage.getItem(nameKey()) || "Anonimo");
      }catch(e){
        showToast("Backend non raggiungibile ‚ùå");
      }

      // UI iniziale
      applyMaxSizingForN(selectedN);

      try{
        await loadOrCreate_();
      }catch(e){
        showToast("Errore caricamento cartelle ‚ùå");
      }

      // primo delta: prende tutto (estratti finora)
      await pollDelta(true);
      updateTopInfo_();

      // poll continuo (leggero)
      setInterval(() => pollDelta(false), POLL_MS);
    })();
  </script>
</body>
</html>
